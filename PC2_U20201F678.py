# -*- coding: utf-8 -*-
"""Codigo-Subir a Github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QykM-RUClOB0cS8IVkuZcqddw7YMINtl
"""

!pip install --quiet tqdm

import requests
import pandas as pd
import networkx as nx
import time
import random
from tqdm import tqdm
import matplotlib.pyplot as plt

MAX_COINS = 1000   # ajustar según necesidad; 1000 cumple el enunciado
PER_PAGE = 250     # CoinGecko max por página
CEX_LIST = {"Binance", "Coinbase Pro", "Coinbase", "Kraken", "OKX", "KuCoin", "Huobi"}
KNOWN_HALVING = {"bitcoin", "litecoin", "bitcoin-cash", "dash"}
TARGET_CATEGORIES = {
    "Inteligencia Artificial": {"singularitynet", "fetch-ai", "render-token"},
    "Videojuegos": {"axie-infinity", "gala", "immutable-x"},
    "RWA": {"ondo-finance", "centrifuge", "maple"},
    "Memes": {"dogecoin", "shiba-inu", "pepe"}
}
EXCHANGES_REFERENCE = ["Binance", "Coinbase", "Kraken", "OKX", "KuCoin"]

def get_markets_pages(max_coins=MAX_COINS):
    url = "https://api.coingecko.com/api/v3/coins/markets"
    per_page = PER_PAGE
    pages = (max_coins // per_page) + (1 if max_coins % per_page else 0)
    all_markets = []
    for page in range(1, pages+1):
        params = {
            "vs_currency": "usd",
            "order": "market_cap_desc",
            "per_page": per_page,
            "page": page,
            "sparkline": False
        }
        r = requests.get(url, params=params)
        if r.status_code != 200:
            raise Exception(f"CoinGecko markets error: {r.status_code} {r.text}")
        all_markets.extend(r.json())
        time.sleep(1)
        if len(all_markets) >= max_coins:
            break
    return all_markets[:max_coins]

def fetch_coin_detail(coin_id, session=None):
    url = f"https://api.coingecko.com/api/v3/coins/{coin_id}"
    params = {
        "localization": "false",
        "tickers": "true",
        "market_data": "true",
        "community_data": "true",
        "developer_data": "true",
        "sparkline": "false"
    }
    s = session or requests
    r = s.get(url, params=params)
    if r.status_code != 200:
        return None
    return r.json()

def assign_category_by_id(coin_id):
    for cat, ids in TARGET_CATEGORIES.items():
        if coin_id in ids:
            return cat
    return "Otros"

def detect_listed_in_cex(tickers):
    if not tickers:
        return 0, []  # no listado
    cex_found = set()
    for t in tickers:
        market = t.get("market", {}).get("name")
        if market and market in CEX_LIST:
            cex_found.add(market)
    return (1 if cex_found else 0), list(cex_found)

def extract_contracts_from_platforms(platforms):
    contracts = []
    if isinstance(platforms, dict):
        for chain, addr in platforms.items():
            if addr:  # si hay direccion de contrato
                contracts.append((chain, addr))
    return contracts

print("Descargando lista de mercados (CoinGecko)...")
markets = get_markets_pages(MAX_COINS)
print(f"Monedas descargadas: {len(markets)}")

rows = []
session = requests.Session()
pbar = tqdm(markets, desc="Extrayendo detalles", unit="coin")
for m in pbar:
    coin_id = m.get("id")
    try:
        detail = fetch_coin_detail(coin_id, session=session)
    except Exception as e:
        detail = None
    if detail is None:
        row = {
            "Proyecto": coin_id,
            "Nombre": m.get("name"),
            "Symbol": m.get("symbol"),
            "Valor_USD": m.get("current_price"),
            "MarketCap": m.get("market_cap"),
            "Ranking": m.get("market_cap_rank"),
            "Volumen24h": m.get("total_volume"),
            "Pct_Volumen": (m.get("total_volume") or 0) / ((m.get("market_cap") or 1)),
            "Circulating": m.get("circulating_supply"),
            "Total_Supply": m.get("total_supply"),
            "Max_Supply": m.get("max_supply"),
            "Comunidad": None,
            "Difusion": None,
            "Calificacion": None,
            "Halving": 1 if coin_id in KNOWN_HALVING else 0,
            "Multichain": None,
            "Listado_CEX": 0,
            "CEX_list": [],
            "Contratos": [],
            "Billeteras_Soportadas": None,
            "Exploradores": None
        }
        rows.append(row)
        time.sleep(0.6)
        continue

    community = detail.get("community_data", {})
    dev = detail.get("developer_data", {})
    public_interest = detail.get("public_interest_stats", {})
    links = detail.get("links", {})
    platforms = detail.get("platforms", {})
    tickers = detail.get("tickers", [])

    twitter = community.get("twitter_followers") or 0
    reddit = community.get("reddit_subscribers") or 0
    fb = community.get("facebook_likes") or 0
    tg = community.get("telegram_channel_user_count") or 0
    comunidad_metric = twitter + reddit + fb + tg

    import math
    difusion = math.log1p(comunidad_metric) / (1 + math.log1p(comunidad_metric)) if comunidad_metric > 0 else 0

    public_interest_score = detail.get("public_interest_score")
    community_score = detail.get("community_score")
    developer_score = detail.get("developer_score")
    if public_interest_score is not None:
        calificacion = public_interest_score
    else:
        scores = [s for s in [community_score, developer_score] if s is not None]
        calificacion = sum(scores) / len(scores) if scores else None

    halving = 1 if coin_id in KNOWN_HALVING else 0

    multichain = 1 if len([k for k,v in (platforms or {}).items() if v]) > 1 else 0

    listado_cex, cex_found = detect_listed_in_cex(tickers)

    contratos = extract_contracts_from_platforms(platforms)

    billeteras_soportadas = len([k for k,v in (platforms or {}).items() if v])

    blockchain_sites = links.get("blockchain_site") or []
    explorers = [u for u in blockchain_sites if u] or None

    row = {
        "Proyecto": coin_id,
        "Nombre": detail.get("name"),
        "Symbol": detail.get("symbol"),
        "Valor_USD": detail.get("market_data", {}).get("current_price", {}).get("usd"),
        "MarketCap": detail.get("market_data", {}).get("market_cap", {}).get("usd"),
        "Ranking": detail.get("market_cap_rank"),
        "Volumen24h": detail.get("market_data", {}).get("total_volume", {}).get("usd"),
        "Pct_Volumen": (detail.get("market_data", {}).get("total_volume", {}).get("usd") or 0) / ((detail.get("market_data", {}).get("market_cap", {}).get("usd") or 1)),
        "Circulating": detail.get("market_data", {}).get("circulating_supply"),
        "Total_Supply": detail.get("market_data", {}).get("total_supply"),
        "Max_Supply": detail.get("market_data", {}).get("max_supply"),
        "Comunidad": comunidad_metric,
        "Difusion": difusion,
        "Calificacion": calificacion,
        "Halving": halving,
        "Multichain": multichain,
        "Listado_CEX": listado_cex,
        "CEX_list": cex_found,
        "Contratos": contratos,
        "Billeteras_Soportadas": billeteras_soportadas,
        "Exploradores": explorers
    }
    rows.append(row)

    time.sleep(0.7)

df_nodes = pd.DataFrame(rows)
print("\nNodos (coins) extraídos:", df_nodes.shape[0])
display(df_nodes.head(10))

def asignar_cat_por_id(coin_id):
    for cat, ids in TARGET_CATEGORIES.items():
        if coin_id in ids:
            return cat
    return "Otros"

df_nodes["Categoria"] = df_nodes["Proyecto"].apply(asignar_cat_por_id)

G = nx.Graph()

categorias = list(TARGET_CATEGORIES.keys()) + ["Otros"]
for c in categorias:
    G.add_node(c, tipo="Categoria")

for ex in EXCHANGES_REFERENCE:
    G.add_node(ex, tipo="Exchange")

for _, r in df_nodes.iterrows():
    nid = r["Proyecto"]
    attrs = r.to_dict()
    attrs["tipo"] = "Proyecto"
    G.add_node(nid, **attrs)

    peso_cat = 0
    if pd.notna(r["Calificacion"]) and r["Difusion"] is not None:
        try:
            peso_cat = float(r["Calificacion"]) * float(r["Difusion"])
        except:
            peso_cat = 0
    G.add_edge(nid, r["Categoria"], peso=peso_cat)

    if isinstance(r["CEX_list"], list) and r["CEX_list"]:
        for ex in r["CEX_list"]:
            # normalizar nombre si necesario
            ex_norm = ex if ex in EXCHANGES_REFERENCE else random.choice(EXCHANGES_REFERENCE)
            peso_ex = (1.0 / r["Ranking"]) if r["Ranking"] and r["Ranking"]>0 else ( (r["MarketCap"] or 0) / 1e9 )
            G.add_edge(nid, ex_norm, peso=peso_ex)
    else:
        ex_norm = random.choice(EXCHANGES_REFERENCE)
        peso_ex = ( (r["Volumen24h"] or 0) / ((r["MarketCap"] or 1)+1) )
        G.add_edge(nid, ex_norm, peso=peso_ex)

print("\nGrafo: nodos =", G.number_of_nodes(), " aristas =", G.number_of_edges())

dc = nx.degree_centrality(G)
top10 = sorted(dc.items(), key=lambda x: x[1], reverse=True)[:15]
print("\nTop nodos por centralidad de grado (top 15):")
for n,v in top10:
    print(n, round(v,5))

sample_nodes = random.sample(list(G.nodes()), min(100, G.number_of_nodes()))
subG = G.subgraph(sample_nodes)
plt.figure(figsize=(12,9))
pos = nx.spring_layout(subG, seed=42)
nx.draw(subG, pos, with_labels=True, node_size=200, font_size=6)
plt.title("Subgrafo de ejemplo (muestra de 100 nodos)")
plt.show()

edges_df = nx.to_pandas_edgelist(G)
nodes_df = pd.DataFrame.from_dict(dict(G.nodes(data=True)), orient="index").reset_index().rename(columns={"index":"Proyecto"})

nodes_df.to_csv("criptomercado_nodes.csv", index=False)
edges_df.to_csv("criptomercado_edges.csv", index=False)
print("\nCSV guardados: 'criptomercado_nodes.csv' y 'criptomercado_edges.csv'")

import matplotlib.pyplot as plt
import random

# -------------------------------
# 1. Resumen del grafo
# -------------------------------
print("===== Resumen del Grafo =====")
print("Nodos totales:", G.number_of_nodes())
print("Aristas totales:", G.number_of_edges())

# -------------------------------
# 2. Vista previa de los nodos (dataset)
# -------------------------------
print("\n===== Vista previa de los primeros 10 nodos =====")
display(nodes_df.head(10))

# -------------------------------
# 3. Distribución de categorías
# -------------------------------
print("\n===== Distribución de proyectos por categoría =====")
if "Categoria" in nodes_df.columns:
    print(nodes_df["Categoria"].value_counts())
else:
    print("No existe la columna 'Categoria' en nodes_df.")

# -------------------------------
# 4. Visualización de subgrafo (100 nodos aleatorios)
# -------------------------------
print("\n===== Subgrafo de ejemplo (100 nodos) =====")
sample_nodes = random.sample(list(G.nodes()), min(100, G.number_of_nodes()))
subG = G.subgraph(sample_nodes)
plt.figure(figsize=(12,9))
pos = nx.spring_layout(subG, seed=42)
nx.draw(subG, pos, with_labels=True, node_size=200, font_size=6)
plt.title("Subgrafo de ejemplo (100 nodos)")
plt.show()